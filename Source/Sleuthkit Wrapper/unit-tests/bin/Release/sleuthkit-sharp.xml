<?xml version="1.0"?>
<doc>
    <assembly>
        <name>sleuthkit-sharp</name>
    </assembly>
    <members>
        <member name="T:SleuthKit.Directory">
            <summary>
            A directory! What else..  Roughly equivalent to TSK_FS_DIR
            </summary>
        </member>
        <member name="T:SleuthKit.FileSystemEntry">
            <summary>
            Used to contain common properties of File and Directory.
            </summary>
        </member>
        <member name="P:SleuthKit.FileSystemEntry.Size">
            <summary>
            Size of file content, in bytes
            </summary>
        </member>
        <member name="P:SleuthKit.FileSystemEntry.MetadataWriteTime">
            <summary>
            Filesystem metadata last write time
            </summary>
        </member>
        <member name="P:SleuthKit.FileSystemEntry.LastWriteTime">
            <summary>
            File content last write time
            </summary>
        </member>
        <member name="P:SleuthKit.FileSystemEntry.LastAccessTime">
            <summary>
            File content last access time
            </summary>
        </member>
        <member name="P:SleuthKit.FileSystemEntry.CreationTime">
            <summary>
            File creation time
            </summary>
        </member>
        <member name="P:SleuthKit.FileSystemEntry.FileSystem">
            <summary>
            Handle to the filesystem that this file comes from
            </summary>
        </member>
        <member name="P:SleuthKit.FileSystemEntry.Name">
            <summary>
            The filename
            </summary>
        </member>
        <member name="P:SleuthKit.FileSystemEntry.Type">
            <summary>
            The type
            </summary>
        </member>
        <member name="P:SleuthKit.FileSystemEntry.Address">
            <summary>
            The filesystem identifier, or inode of this file
            </summary>
        </member>
        <member name="M:SleuthKit.Directory.Dispose">
            <summary>
            Releases resources
            </summary>
        </member>
        <member name="M:SleuthKit.Directory.GetFileStruct">
            <summary>
            open file
            </summary>
            <returns></returns>
        </member>
        <member name="P:SleuthKit.Directory.Path">
            <summary>
            The full path
            </summary>
        </member>
        <member name="P:SleuthKit.Directory.EntryCount">
            <summary>
            Number of entries in this directory
            </summary>
        </member>
        <member name="P:SleuthKit.Directory.EntryNames">
            <summary>
            Lists the entries in this directory.
            </summary>
        </member>
        <member name="P:SleuthKit.Directory.Files">
            <summary>
            Files
            </summary>
        </member>
        <member name="P:SleuthKit.Directory.Directories">
            <summary>
            Directories
            </summary>
        </member>
        <member name="P:SleuthKit.Directory.Entries">
            <summary>
            The entries in this directory
            </summary>
        </member>
        <member name="T:SleuthKit.DiskImage">
            <summary>
            An object encapsulating the SleuthKit disk image functions. 
            See http://www.sleuthkit.org/sleuthkit/docs/api-docs/imgpage.html for more info.
            </summary>
        </member>
        <member name="T:SleuthKit.IContent">
            <summary>
            An item that has content.  Size is provided separately because sometimes getting a stream to content is expensive, and it is nice to provide the stream length without opening the stream.  It is worth noting, however, that sometimes IContent implementations will specify a Size that is not consistent with the amount of bytes you can read from the <c>Stream</c> returned by <c>OpenRead</c>.  Sometimes we don't know that content is unavailable until the caller is reading it, so take the <c>Size</c> with a grain of salt.
            </summary>
        </member>
        <member name="M:SleuthKit.IContent.OpenRead">
            <summary>
            Opens the content for reading.  Since this library is designed for reading disk images, there isn't going to be an <c>OpenWrite</c>.
            </summary>
            <returns></returns>
        </member>
        <member name="P:SleuthKit.IContent.Size">
            <summary>
            The length of the content, in bytes.  See remarks for the IContent interface for more information about this property.  Basically it is here so that you don't need to call <c>OpenRead</c> just to get the stream length.
            </summary>
        </member>
        <member name="M:SleuthKit.DiskImage.#ctor(System.IO.FileInfo[])">
            <summary>
            ctor
            </summary>
            <param name="files"></param>
        </member>
        <member name="M:SleuthKit.DiskImage.#ctor(System.IO.FileInfo)">
            <summary>
            Initializes a new disk image.
            </summary>
            <param name="file">The disk image (dd, e01, etc)</param>
        </member>
        <member name="M:SleuthKit.DiskImage.#ctor(System.Collections.Generic.IEnumerable{System.IO.FileInfo})">
            <summary>
            ctor
            </summary>
            <param name="_files"></param>
        </member>
        <member name="M:SleuthKit.DiskImage.Init(System.Collections.Generic.IEnumerable{System.IO.FileInfo})">
            <summary>
            Initializes sleuthkit with the specified image files (calls tsk_img_open_* methods)
            </summary>
            <param name="_files"></param>
        </member>
        <member name="M:SleuthKit.DiskImage.ToString">
            <summary>
            A little diagnostic info about the disk image
            </summary>
            <returns></returns>
        </member>
        <member name="M:SleuthKit.DiskImage.ReadBytes(System.Int64,System.Byte[],System.Int32)">
            <summary>
            allows reading specified portions of the disk image
            </summary>
            <param name="offset"></param>
            <param name="buf"></param>
            <param name="buflen"></param>
            <returns></returns>
        </member>
        <member name="M:SleuthKit.DiskImage.OpenRead">
            <summary>
            Returns a stream to the disk image contents.  Particularly useful if you are reading something other than a dd image.  
            </summary>
            <returns></returns>
        </member>
        <member name="M:SleuthKit.DiskImage.OpenVolumeSystem">
            <summary>
            Opens a volume system.
            </summary>
            <returns></returns>
        </member>
        <member name="M:SleuthKit.DiskImage.OpenFileSystem(SleuthKit.FileSystemType,System.Int64)">
            <summary>
            Opens a filesystem - for images with no partition table, i.e. volume images, or most SD cards and thumb drives that are formatted  .
            </summary>
            <param name="fstype"></param>
            <param name="offset"></param>
            <returns></returns>
        </member>
        <member name="M:SleuthKit.DiskImage.GetFileSystems">
            <summary>
            Returns an enumeration of all filesystems on the disk image.  Here for convenience when writing LINQ queries.
            </summary>
            <returns></returns>
        </member>
        <member name="M:SleuthKit.DiskImage.Dispose">
            <summary>
            Releases resources
            </summary>
        </member>
        <member name="P:SleuthKit.DiskImage.Size">
            <summary>
            the size of this disk image, in bytes
            </summary>
        </member>
        <member name="P:SleuthKit.DiskImage.SectorSize">
            <summary>
            the size of a sector on this disk image, in bytes
            </summary>
        </member>
        <member name="T:SleuthKit.StructureMagic">
            <summary>
            Constants for use when dealing with native structures and methods.
            </summary>
        </member>
        <member name="F:SleuthKit.StructureMagic.FilesystemFileTag">
            <summary>
            TSK_FS_FILE_TAG 
            </summary>
        </member>
        <member name="F:SleuthKit.StructureMagic.FilesystemNameTag">
            <summary>
            TSK_FS_NAME_TAG 
            </summary>
        </member>
        <member name="F:SleuthKit.StructureMagic.FilesystemMetadataTag">
            <summary>
            TSK_FS_META_TAG
            </summary>
        </member>
        <member name="F:SleuthKit.StructureMagic.FilesystemInfoTag">
            <summary>
            TSK_FS_INFO_TAG
            </summary>
        </member>
        <member name="F:SleuthKit.StructureMagic.FilesystemBlockTag">
            <summary>
            TSK_FS_BLOCK_TAG
            </summary>
        </member>
        <member name="F:SleuthKit.StructureMagic.FilesystemDirectoryTag">
            <summary>
            TSK_FS_DIR_TAG
            </summary>
        </member>
        <member name="T:SleuthKit.FilterReturnCode">
            <summary>
            Return value from filter menus 
            </summary>
        </member>
        <member name="F:SleuthKit.FilterReturnCode.Continue">
            <summary>
            TSK_FILTER_CONT, Framework should continue to process this object
            </summary>
        </member>
        <member name="F:SleuthKit.FilterReturnCode.Stop">
            <summary>
            TSK_FILTER_STOP, Framework should stop processing the image
            </summary>
        </member>
        <member name="F:SleuthKit.FilterReturnCode.Skip">
            <summary>
            TSK_FILTER_SKIP, Framework should skip this object and go on to the next
            </summary>
        </member>
        <member name="T:SleuthKit.VolumeSystemType">
            <summary>
            Volume system type enumeration
            </summary>
        </member>
        <member name="F:SleuthKit.VolumeSystemType.Autodetect">
            <summary>
            TSK_VS_TYPE_DETECT, Use autodetection methods
            </summary>
        </member>
        <member name="F:SleuthKit.VolumeSystemType.MBR">
            <summary>
            TSK_VS_TYPE_DOS, DOS Partition table
            </summary>
        </member>
        <member name="F:SleuthKit.VolumeSystemType.BSD">
            <summary>
            TSK_VS_TYPE_BSD, BSD Partition table
            </summary>
        </member>
        <member name="F:SleuthKit.VolumeSystemType.Sun">
            <summary>
            TSK_VS_TYPE_SUN, Sun VTOC
            </summary>
        </member>
        <member name="F:SleuthKit.VolumeSystemType.Apple">
            <summary>
            TSK_VS_TYPE_MAC, Mac partition table (APM)
            </summary>
        </member>
        <member name="F:SleuthKit.VolumeSystemType.GPT">
            <summary>
            TSK_VS_TYPE_GPT, GPT partition table
            </summary>
        </member>
        <member name="F:SleuthKit.VolumeSystemType.DatabaseFiller">
            <summary>
            TSK_VS_TYPE_DBFILLER, fake partition table type for loaddb (for images that do not have a volume system)
            </summary>
        </member>
        <member name="F:SleuthKit.VolumeSystemType.Unsupported">
            <summary>
            TSK_VS_TYPE_UNSUPP, Unsupported
            </summary>
        </member>
        <member name="T:SleuthKit.ReturnCode">
            <summary>
            Return value
            </summary>
        </member>
        <member name="F:SleuthKit.ReturnCode.OK">
            <summary>
            Ok -- success
            </summary>
        </member>
        <member name="F:SleuthKit.ReturnCode.Error">
            <summary>
            System error -- should abort
            </summary>
        </member>
        <member name="F:SleuthKit.ReturnCode.Corrupt">
            <summary>
            Data is corrupt, can still process another set of data
            </summary>
        </member>
        <member name="F:SleuthKit.ReturnCode.Stop">
            <summary>
            Stop further processing, not an error though. 
            </summary>
        </member>
        <member name="T:SleuthKit.FilesystemNameType">
            <summary>
            Managed version of TSK_FS_NAME_TYPE_ENUM
            </summary>
        </member>
        <member name="F:SleuthKit.FilesystemNameType.Unknown">
            <summary>
            Unknown
            </summary>
            <remarks>TSK_FS_NAME_TYPE_UNDEF </remarks>
        </member>
        <member name="F:SleuthKit.FilesystemNameType.NamedPipe">
            <summary>
            Named pipe
            </summary>
            <remarks>TSK_FS_NAME_TYPE_FIFO </remarks>
        </member>
        <member name="F:SleuthKit.FilesystemNameType.CharacterDevice">
            <summary>
            Character Device
            </summary>
            <remarks>TSK_FS_NAME_TYPE_CHR </remarks>
        </member>
        <member name="F:SleuthKit.FilesystemNameType.Directory">
            <summary>
            Directory 
            </summary>
            <remarks>TSK_FS_NAME_TYPE_DIR </remarks>
        </member>
        <member name="F:SleuthKit.FilesystemNameType.BlockDevice">
            <summary>
            Block device
            </summary>
            <remarks>TSK_FS_NAME_TYPE_BLK</remarks>
        </member>
        <member name="F:SleuthKit.FilesystemNameType.Regular">
            <summary>
            Regular File
            </summary>
            <remarks>TSK_FS_NAME_TYPE_REG</remarks>
        </member>
        <member name="F:SleuthKit.FilesystemNameType.SymbolicLink">
            <summary>
            Symbolic link 
            </summary>
            <remarks>TSK_FS_NAME_TYPE_LNK</remarks>
        </member>
        <member name="F:SleuthKit.FilesystemNameType.Socket">
            <summary>
            Socket
            </summary>
            <remarks>TSK_FS_NAME_TYPE_SOCK</remarks>
        </member>
        <member name="F:SleuthKit.FilesystemNameType.ShadowInode">
            <summary>
            Shadow inode (solaris) 
            </summary>
            <remarks>TSK_FS_NAME_TYPE_SHAD</remarks>
        </member>
        <member name="F:SleuthKit.FilesystemNameType.Whiteout">
            <summary>
            Whiteout (openbsd) 
            </summary>
            <remarks>TSK_FS_NAME_TYPE_WHT</remarks>
        </member>
        <member name="F:SleuthKit.FilesystemNameType.Virtual">
            <summary>
            Special (TSK added "Virtual" files)
            </summary>
            <remarks>TSK_FS_NAME_TYPE_VIRT </remarks>
        </member>
        <member name="T:SleuthKit.FileSystemMetaContentType">
            <summary>
            Managed version of TSK_FS_META_CONTENT_TYPE_ENUM.
            </summary>
        </member>
        <member name="F:SleuthKit.FileSystemMetaContentType.Default">
            <summary>
            TSK_FS_META_CONTENT_TYPE_DEFAULT, Default value
            </summary>
        </member>
        <member name="F:SleuthKit.FileSystemMetaContentType.Ext4Extents">
            <summary>
            TSK_FS_META_CONTENT_TYPE_EXT4_EXTENTS, Ext4 with extents instead of individual pointers
            </summary>
        </member>
        <member name="T:SleuthKit.NameFlags">
            <summary>
            Managed version of TSK_FS_NAME_FLAG_ENUM, Filesystem name flags
            </summary>
        </member>
        <member name="F:SleuthKit.NameFlags.Allocated">
            <summary>
            Name is in an allocated state
            </summary>
        </member>
        <member name="F:SleuthKit.NameFlags.Unallocated">
            <summary>
            Name is in an unallocated state
            </summary>
        </member>
        <member name="T:SleuthKit.MetadataFlags">
            <summary>
            Managed version of TSK_FS_META_FLAG_ENUM, Metadata flags
            </summary>
        </member>
        <member name="F:SleuthKit.MetadataFlags.Allocated">
            <summary>
            TSK_FS_META_FLAG_ALLOC, Metadata structure is currently in an allocated state
            </summary>
        </member>
        <member name="F:SleuthKit.MetadataFlags.Unallocated">
            <summary>
            TSK_FS_META_FLAG_UNALLOC, Metadata structure is currently in an unallocated state
            </summary>
        </member>
        <member name="F:SleuthKit.MetadataFlags.Used">
            <summary>
            TSK_FS_META_FLAG_USED, Metadata structure has been allocated at least once
            </summary>
        </member>
        <member name="F:SleuthKit.MetadataFlags.Unused">
            <summary>
            TSK_FS_META_FLAG_UNUSED, Metadata structure has never been allocated. 
            </summary>
        </member>
        <member name="F:SleuthKit.MetadataFlags.Compressed">
            <summary>
            TSK_FS_META_FLAG_COMP, The file contents are compressed. 
            </summary>
        </member>
        <member name="F:SleuthKit.MetadataFlags.Orphan">
            <summary>
            TSK_FS_META_FLAG_ORPHAN, Return only metadata structures that have no file name pointing to the (inode_walk flag only)
            </summary>
        </member>
        <member name="T:SleuthKit.MetadataAttributeFlags">
            <summary>
            Managed version of TSK_FS_META_ATTR_FLAG_ENUM, Meta attribute flags
            </summary>
        </member>
        <member name="F:SleuthKit.MetadataAttributeFlags.Empty">
            <summary>
            TSK_FS_META_ATTR_EMPTY, The data in the attributes (if any) is not for this file
            </summary>
        </member>
        <member name="F:SleuthKit.MetadataAttributeFlags.Studied">
            <summary>
            TSK_FS_META_ATTR_STUDIED, The data in the attributes are for this file
            </summary>
        </member>
        <member name="F:SleuthKit.MetadataAttributeFlags.Error">
            <summary>
            TSK_FS_META_ATTR_ERROR, The attributes for this file could not be loaded
            </summary>
        </member>
        <member name="T:SleuthKit.MetadataType">
            <summary>
            Managed version of TSK_FS_META_TYPE_ENUM, Values for the mode field -- which identifies the file type and permissions.
            </summary>
        </member>
        <member name="F:SleuthKit.MetadataType.Undefined">
            <summary>
            TSK_FS_META_TYPE_UNDEF, Undefined
            </summary>
        </member>
        <member name="F:SleuthKit.MetadataType.Regular">
            <summary>
            TSK_FS_META_TYPE_REG, Regular file
            </summary>
        </member>
        <member name="F:SleuthKit.MetadataType.Directory">
            <summary>
            TSK_FS_META_TYPE_DIR, Directory file
            </summary>
        </member>
        <member name="F:SleuthKit.MetadataType.NamedPipe">
            <summary>
            TSK_FS_META_TYPE_FIFO, Named pipe (fifo) 
            </summary>
        </member>
        <member name="F:SleuthKit.MetadataType.CharacterDevice">
            <summary>
            TSK_FS_META_TYPE_CHR, Character device 
            </summary>
        </member>
        <member name="F:SleuthKit.MetadataType.BlockDevice">
            <summary>
            TSK_FS_META_TYPE_BLK, Block device 
            </summary>
        </member>
        <member name="F:SleuthKit.MetadataType.Symlink">
            <summary>
            TSK_FS_META_TYPE_LNK, Symbolic link
            </summary>
        </member>
        <member name="F:SleuthKit.MetadataType.Shadow">
            <summary>
            TSK_FS_META_TYPE_SHAD, SOLARIS ONLY 
            </summary>
        </member>
        <member name="F:SleuthKit.MetadataType.Socket">
            <summary>
            TSK_FS_META_TYPE_SOCK, UNIX domain socket
            </summary>
        </member>
        <member name="F:SleuthKit.MetadataType.Whiteout">
            <summary>
            TSK_FS_META_TYPE_WHT, Whiteout
            </summary>
        </member>
        <member name="F:SleuthKit.MetadataType.VirtualFile">
            <summary>
            TSK_FS_META_TYPE_VIRT, "Virtual File" created by TSK for file system areas
            </summary>
        </member>
        <member name="T:SleuthKit.MetadataMode">
            <summary>
            Managed version of TSK_FS_META_MODE_ENUM.  The following describe the file permissions
            </summary>
        </member>
        <member name="F:SleuthKit.MetadataMode.TSK_FS_META_MODE_ISUID">
            <summary>
            set user id on execution 
            </summary>
        </member>
        <member name="F:SleuthKit.MetadataMode.TSK_FS_META_MODE_ISGID">
            <summary>
            set group id on execution 
            </summary>
        </member>
        <member name="F:SleuthKit.MetadataMode.TSK_FS_META_MODE_ISVTX">
            <summary>
            sticky bit 
            </summary>
        </member>
        <member name="F:SleuthKit.MetadataMode.TSK_FS_META_MODE_IRUSR">
            <summary>
            R for owner 
            </summary>
        </member>
        <member name="F:SleuthKit.MetadataMode.TSK_FS_META_MODE_IWUSR">
            <summary>
            W for owner 
            </summary>
        </member>
        <member name="F:SleuthKit.MetadataMode.TSK_FS_META_MODE_IXUSR">
            <summary>
            X for owner 
            </summary>
        </member>
        <member name="F:SleuthKit.MetadataMode.TSK_FS_META_MODE_IRGRP">
            <summary>
            R for group 
            </summary>
        </member>
        <member name="F:SleuthKit.MetadataMode.TSK_FS_META_MODE_IWGRP">
            <summary>
            W for group 
            </summary>
        </member>
        <member name="F:SleuthKit.MetadataMode.TSK_FS_META_MODE_IXGRP">
            <summary>
            X for group 
            </summary>
        </member>
        <member name="F:SleuthKit.MetadataMode.TSK_FS_META_MODE_IROTH">
            <summary>
            R for other 
            </summary>
        </member>
        <member name="F:SleuthKit.MetadataMode.TSK_FS_META_MODE_IWOTH">
            <summary>
            W for other 
            </summary>
        </member>
        <member name="F:SleuthKit.MetadataMode.TSK_FS_META_MODE_IXOTH">
            <summary>
            X for other 
            </summary>
        </member>
        <member name="T:SleuthKit.DirWalkFlags">
            <summary>
            Managed version of TSK_FS_DIR_WALK_FLAG_ENUM
            </summary>
        </member>
        <member name="F:SleuthKit.DirWalkFlags.NoFlags">
            <summary>
            TSK_FS_DIR_WALK_FLAG_NONE, No Flags
            </summary>
        </member>
        <member name="F:SleuthKit.DirWalkFlags.Allocated">
            <summary>
            TSK_FS_DIR_WALK_FLAG_ALLOC, Return allocated names in callback
            </summary>
        </member>
        <member name="F:SleuthKit.DirWalkFlags.Unallocated">
            <summary>
            TSK_FS_DIR_WALK_FLAG_UNALLOC, Return unallocated names in callback
            </summary>
        </member>
        <member name="F:SleuthKit.DirWalkFlags.Recurse">
            <summary>
            TSK_FS_DIR_WALK_FLAG_RECURSE, Recurse into sub-directories 
            </summary>
        </member>
        <member name="F:SleuthKit.DirWalkFlags.NoOrphan">
            <summary>
            TSK_FS_DIR_WALK_FLAG_NOORPHAN, Do not return (or recurse into) the special Orphan directory
            </summary>
        </member>
        <member name="T:SleuthKit.WalkReturnEnum">
            <summary>
            Return values from a dir walk
            </summary>
        </member>
        <member name="F:SleuthKit.WalkReturnEnum.Continue">
            <summary>
            TSK_WALK_CONT, Walk function should continue to next object
            </summary>
        </member>
        <member name="F:SleuthKit.WalkReturnEnum.Stop">
            <summary>
            TSK_WALK_STOP,  Walk function should stop processing units and return OK
            </summary>
        </member>
        <member name="F:SleuthKit.WalkReturnEnum.Error">
            <summary>
            TSK_WALK_ERROR, Walk function should stop processing units and return error
            </summary>
        </member>
        <member name="F:SleuthKit.FilesystemInfoFlag.None">
            <summary>
            TSK_FS_INFO_FLAG_NONE, No Flags
            </summary>
        </member>
        <member name="F:SleuthKit.FilesystemInfoFlag.HasSequenceNumbers">
            <summary>
            TSK_FS_INFO_FLAG_HAVE_SEQ, File system has sequence numbers in the inode addresses.
            </summary>
        </member>
        <member name="F:SleuthKit.FilesystemInfoFlag.HasNanoSec">
            <summary>
            TSK_FS_INFO_FLAG_HAVE_NANOSEC, Nano second field in times will be set.
            </summary>
        </member>
        <member name="F:SleuthKit.FileReadFlag.None">
            <summary>
            TSK_FS_FILE_READ_FLAG_NONE 
            </summary>
        </member>
        <member name="F:SleuthKit.FileReadFlag.Slack">
            <summary>
            TSK_FS_FILE_READ_FLAG_SLACK, Allow read access into slack space
            </summary>
        </member>
        <member name="F:SleuthKit.FileReadFlag.NoID">
            <summary>
            TSK_FS_FILE_READ_FLAG_NOID , Ignore the Id argument given in the API (use only the type)
            </summary>
        </member>
        <member name="T:SleuthKit.FileSystemBlockFlags">
            <summary>
            Flags that are used in TSK_FS_BLOCK and in callback of file_walk. 
            Note that some of these are dependent.  A block can be either TSK_FS_BLOCK_FLAG_ALLOC or TSK_FS_BLOCK_FLAG_UNALLOC.  
            It can be one of TSK_FS_BLOCK_FLAG_RAW, TSK_FS_BLOCK_FLAG_BAD, TSK_FS_BLOCK_FLAG_RES, TSK_FS_BLOCK_FLAG_SPARSE, or TSK_FS_BLOCK_FLAG_COMP.  
            Note that some of these are set only by file_walk because they are file-level details, such as compression and sparse.
            </summary>
            <remarks>TSK_FS_BLOCK_FLAG_ENUM</remarks>
        </member>
        <member name="F:SleuthKit.FileSystemBlockFlags.Unused">
            <summary>
            TSK_FS_BLOCK_FLAG_UNUSED, Used to show that TSK_FS_BLOCK structure has no data in it
            </summary>
        </member>
        <member name="F:SleuthKit.FileSystemBlockFlags.Allocated">
            <summary>
            TSK_FS_BLOCK_FLAG_ALLOC, Block is allocated (and not TSK_FS_BLOCK_FLAG_UNALLOC)
            </summary>
        </member>
        <member name="F:SleuthKit.FileSystemBlockFlags.Unallocated">
            <summary>
            TSK_FS_BLOCK_FLAG_UNALLOC, Block is unallocated (and not TSK_FS_BLOCK_FLAG_ALLOC)
            </summary>
        </member>
        <member name="F:SleuthKit.FileSystemBlockFlags.Content">
            <summary>
            TSK_FS_BLOCK_FLAG_CONT, Block (could) contain file content (and not TSK_FS_BLOCK_FLAG_META)
            </summary>
        </member>
        <member name="F:SleuthKit.FileSystemBlockFlags.Metadata">
            <summary>
            TSK_FS_BLOCK_FLAG_META, Block (could) contain file system metadata (and not TSK_FS_BLOCK_FLAG_CONT)
            </summary>
        </member>
        <member name="F:SleuthKit.FileSystemBlockFlags.Bad">
            <summary>
            TSK_FS_BLOCK_FLAG_BAD, Block has been marked as bad by the file system
            </summary>
        </member>
        <member name="F:SleuthKit.FileSystemBlockFlags.Raw">
            <summary>
            TSK_FS_BLOCK_FLAG_RAW, The data has been read raw from the disk (and not COMP or SPARSE)
            </summary>
        </member>
        <member name="F:SleuthKit.FileSystemBlockFlags.Sparse">
            <summary>
            TSK_FS_BLOCK_FLAG_SPARSE, The data passed in the file_walk calback was stored as sparse (all zeros) (and not RAW or COMP)
            </summary>
        </member>
        <member name="F:SleuthKit.FileSystemBlockFlags.Compressed">
            <summary>
            TSK_FS_BLOCK_FLAG_COMP, The data passed in the file_walk callback was stored in a compressed form (and not RAW or SPARSE)
            </summary>
        </member>
        <member name="F:SleuthKit.FileSystemBlockFlags.NTFSResident">
            <summary>
            TSK_FS_BLOCK_FLAG_RES , The data passed in the file_walk callback is from an NTFS resident file
            </summary>
        </member>
        <member name="F:SleuthKit.FileSystemBlockFlags.FlagAonly">
            <summary>
            TSK_FS_BLOCK_FLAG_AONLY, TSK_FS_BLOCK has no content (it could be non-empty, but should be ignored), but the flags and such are accurate
            </summary>
        </member>
        <member name="T:SleuthKit.FileWalkFlag">
            <summary>
            Flags used by tsk_fs_file_walk to determine when the callback function should be used.
            </summary>
        </member>
        <member name="F:SleuthKit.FileWalkFlag.None">
            <summary>
            No Flag.
            </summary>
        </member>
        <member name="F:SleuthKit.FileWalkFlag.Slack">
            <summary>
            Include the file's slack space in the callback.
            </summary>
        </member>
        <member name="F:SleuthKit.FileWalkFlag.NoId">
            <summary>
            Ignore the Id argument given in the API (use only the type).
            </summary>
        </member>
        <member name="F:SleuthKit.FileWalkFlag.AOnly">
            <summary>
            Provide callback with only addresses and no file content.
            </summary>
        </member>
        <member name="F:SleuthKit.FileWalkFlag.NoSparse">
            <summary>
            Do not include sparse blocks in the callback.
            </summary>
        </member>
        <member name="T:SleuthKit.FileSystemType">
            <summary>
            Managed version of TSK_FS_TYPE_ENUM
            </summary>
        </member>
        <member name="F:SleuthKit.FileSystemType.Autodetect">
            <summary>
            TSK_FS_TYPE_DETECT, Use autodetection methods
            </summary>
        </member>
        <member name="F:SleuthKit.FileSystemType.NTFS">
            <summary>
            TSK_FS_TYPE_NTFS, NTFS file system
            </summary>
        </member>
        <member name="F:SleuthKit.FileSystemType.FAT12">
            <summary>
            TSK_FS_TYPE_FAT12, FAT12 file system
            </summary>
        </member>
        <member name="F:SleuthKit.FileSystemType.FAT16">
            <summary>
            TSK_FS_TYPE_FAT16, FAT16 file system
            </summary>
        </member>
        <member name="F:SleuthKit.FileSystemType.FAT32">
            <summary>
            TSK_FS_TYPE_FAT32, FAT32 file system
            </summary>
        </member>
        <member name="F:SleuthKit.FileSystemType.FATAutodetect">
            <summary>
            TSK_FS_TYPE_FAT_DETECT, FAT auto detection
            </summary>
        </member>
        <member name="F:SleuthKit.FileSystemType.UFS1">
            <summary>
            TSK_FS_TYPE_FFS1, UFS1 (FreeBSD, OpenBSD, BSDI ...)
            </summary>
        </member>
        <member name="F:SleuthKit.FileSystemType.UFS1b">
            <summary>
            TSK_FS_TYPE_FFS1B, UFS1b (Solaris - has no type)
            </summary>
        </member>
        <member name="F:SleuthKit.FileSystemType.UFS2">
            <summary>
            TSK_FS_TYPE_FFS2, UFS2 - FreeBSD, NetBSD 
            </summary>
        </member>
        <member name="F:SleuthKit.FileSystemType.UFSAutodetect">
            <summary>
            TSK_FS_TYPE_FFS_DETECT, UFS auto detection
            </summary>
        </member>
        <member name="F:SleuthKit.FileSystemType.ext2">
            <summary>
            TSK_FS_TYPE_EXT2, Ext2 file system
            </summary>
        </member>
        <member name="F:SleuthKit.FileSystemType.ext3">
            <summary>
            TSK_FS_TYPE_EXT3, Ext3 file system
            </summary>
        </member>
        <member name="F:SleuthKit.FileSystemType.extAutodetect">
            <summary>
            TSK_FS_TYPE_EXT_DETECT, ExtX auto detection
            </summary>
        </member>
        <member name="F:SleuthKit.FileSystemType.Swap">
            <summary>
            TSK_FS_TYPE_SWAP, SWAP file system
            </summary>
        </member>
        <member name="F:SleuthKit.FileSystemType.Raw">
            <summary>
            TSK_FS_TYPE_RAW, RAW file system
            </summary>
        </member>
        <member name="F:SleuthKit.FileSystemType.ISO9660">
            <summary>
            TSK_FS_TYPE_ISO9660, ISO9660 file system
            </summary>
        </member>
        <member name="F:SleuthKit.FileSystemType.HFS">
            <summary>
            TSK_FS_TYPE_HFS, HFS file system
            </summary>
        </member>
        <member name="F:SleuthKit.FileSystemType.ext4">
            <summary>
            TSK_FS_TYPE_EXT4, Ext4 file system
            </summary>
        </member>
        <member name="F:SleuthKit.FileSystemType.Yaffs2">
            <summary>
            TSK_FS_TYPE_YAFFS2, YAFFS2 file system
            </summary>
        </member>
        <member name="F:SleuthKit.FileSystemType.Unsupported">
            <summary>
            TSK_FS_TYPE_UNSUPP, Unsupported file system
            </summary>
        </member>
        <member name="T:SleuthKit.Endianness">
            <summary>
            Endian .. little or big .. or middle! 
            </summary>
            <remarks>
            The term big-endian originally comes from Jonathan Swift's satirical novel Gulliver’s Travels by way of Danny Cohen in 1980. In 1726, Swift described tensions in Lilliput and Blefuscu: whereas royal edict in Lilliput requires cracking open one's soft-boiled egg at the small end, inhabitants of the rival kingdom of Blefuscu crack theirs at the big end (giving them the moniker Big-endians). The terms little-endian and endianness have a similar intent. 
            http://en.wikipedia.org/wiki/Endianness
            </remarks>
        </member>
        <member name="F:SleuthKit.Endianness.Little">
            <summary>
            TSK_LIT_ENDIAN, Data is in little endian
            </summary>
        </member>
        <member name="F:SleuthKit.Endianness.Big">
            <summary>
            TSK_BIG_ENDIAN, Data is in big endian
            </summary>
        </member>
        <member name="T:SleuthKit.ImageType">
            <summary>
            TSK_IMG_TYPE_ENUM, Type of image (dd, split, aff, encase, etc)
            </summary>
        </member>
        <member name="F:SleuthKit.ImageType.Autodetect">
            <summary>
            TSK_IMG_TYPE_DETECT, Use autodetection methods
            </summary>
        </member>
        <member name="F:SleuthKit.ImageType.Raw">
            <summary>
            TSK_IMG_TYPE_RAW_SING, Raw single disk image
            </summary>
        </member>
        <member name="F:SleuthKit.ImageType.RawSing">
            <summary>
            TSK_IMG_TYPE_RAW_SING, Raw single (backward compatibility) depreciated
            </summary>
        </member>
        <member name="F:SleuthKit.ImageType.RawSplit">
            <summary>
            TSK_IMG_TYPE_RAW_SPLIT, Raw split (backward compatibility) depreciated
            </summary>
        </member>
        <member name="F:SleuthKit.ImageType.AFF">
            <summary>
            TSK_IMG_TYPE_AFF_AFF, AFF AFF Format
            </summary>
        </member>
        <member name="F:SleuthKit.ImageType.AFD">
            <summary>
            TSK_IMG_TYPE_AFF_AFD , AFD AFF Format
            </summary>
        </member>
        <member name="F:SleuthKit.ImageType.AFM">
            <summary>
            TSK_IMG_TYPE_AFF_AFM, AFM AFF Format
            </summary>
        </member>
        <member name="F:SleuthKit.ImageType.AnyAFF">
            <summary>
            TSK_IMG_TYPE_AFF_ANY, Any format supported by AFFLIB (including beta ones)
            </summary>
        </member>
        <member name="F:SleuthKit.ImageType.EWF">
            <summary>
            TSK_IMG_TYPE_EWF_EWF, EnCase image
            </summary>
        </member>
        <member name="F:SleuthKit.ImageType.Unsupported">
            <summary>
            TSK_IMG_TYPE_UNSUPP, Unsupported disk image type
            </summary>
        </member>
        <member name="T:SleuthKit.VolumeFlags">
            <summary>
            TSK_VS_PART_FLAG_ENUM
            </summary>
        </member>
        <member name="F:SleuthKit.VolumeFlags.Allocated">
            <summary>
            TSK_VS_PART_FLAG_ALLOC, Sectors are allocated to a volume in the volume system
            </summary>
        </member>
        <member name="F:SleuthKit.VolumeFlags.Unallocated">
            <summary>
             TSK_VS_PART_FLAG_UNALLOC, Sectors are not allocated to a volume 
            </summary>
        </member>
        <member name="F:SleuthKit.VolumeFlags.Metadata">
            <summary>
            TSK_VS_PART_FLAG_META, Sectors contain volume system metadata and could also be ALLOC or UNALLOC
            </summary>
        </member>
        <member name="F:SleuthKit.VolumeFlags.All">
            <summary>
            TSK_VS_PART_FLAG_ALL, Show all sectors in the walk. 
            </summary>
        </member>
        <member name="T:SleuthKit.AttributeFlags">
            <summary>
            TSK_FS_ATTR_FLAG_ENUM
            </summary>
        </member>
        <member name="F:SleuthKit.AttributeFlags.None">
            <summary>
            No Flag
            </summary>
        </member>
        <member name="F:SleuthKit.AttributeFlags.InUse">
            <summary>
            Data structure is in use
            </summary>
        </member>
        <member name="F:SleuthKit.AttributeFlags.NonResident">
            <summary>
            Contains non-resident data (i.e. located in blocks)
            </summary>
        </member>
        <member name="F:SleuthKit.AttributeFlags.Resident">
            <summary>
            Contains resident data (i.e. in a small buffer)
            </summary>
        </member>
        <member name="F:SleuthKit.AttributeFlags.Encrypted">
            <summary>
            Contains encrypted data
            </summary>
        </member>
        <member name="F:SleuthKit.AttributeFlags.Compressed">
            <summary>
            Contains compressed data
            </summary>
        </member>
        <member name="F:SleuthKit.AttributeFlags.Sparse">
            <summary>
            Contains sparse data
            </summary>
        </member>
        <member name="F:SleuthKit.AttributeFlags.Recovery">
            <summary>
            Data was determined in file recovery mode
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "F:SleuthKit.AttributeRunFlags.Filler" -->
        <!-- Badly formed XML comment ignored for member "F:SleuthKit.AttributeRunFlags.Sparse" -->
        <member name="T:SleuthKit.AttributeType">
            <summary>
            TSK_FS_ATTR_TYPE_ENUM
            </summary>
        </member>
        <member name="T:SleuthKit.File">
            <summary>
            A file from a filesystem, roughly equates to a TSK_FS_FILE.
            </summary>
        </member>
        <member name="M:SleuthKit.File.#ctor(SleuthKit.FileSystem,SleuthKit.FileHandle,SleuthKit.Directory,System.String)">
            <summary>
            ctor
            </summary>
            <param name="fs"></param>
            <param name="fh"></param>
            <param name="parent"></param>
            <param name="name"></param>
        </member>
        <member name="M:SleuthKit.File.Dispose">
            <summary>
            Releases resources
            </summary>
        </member>
        <member name="M:SleuthKit.File.ReadBytes(System.Int64,System.Byte[],System.Int32)">
            <summary>
            Reads file data
            </summary>
            <param name="offset">The offset.</param>
            <param name="buffer">The buffer.</param>
            <param name="amt">The amt.</param>
            <returns></returns>
            <exception cref="T:SleuthKit.NtfsCompressionException">If a compressed file is corrupt</exception>
            <exception cref="T:System.IO.IOException">If the file reading files for another reason</exception>
        </member>
        <member name="M:SleuthKit.File.WalkFile(SleuthKit.FileContentWalkDelegate,System.IntPtr)">
            <summary>
            Process a file and call a callback function with the file contents. 
            </summary>
            <param name="callback">Callback action to call with content.</param>
            <param name="a_ptr">Pointer that will be passed to callback.</param>
            <returns>returns 1 on error and 0 on success.</returns>
        </member>
        <member name="M:SleuthKit.File.OpenRead">
            <summary>
            Returns a stream to this file's contents.
            </summary>
            <returns></returns>
        </member>
        <member name="P:SleuthKit.File.LongName">
            <summary>
            Long name of the file - use this
            </summary>
        </member>
        <member name="P:SleuthKit.File.FileStruct">
            <summary>
            The underlying TSK_FS_FILE.
            </summary>
        </member>
        <member name="P:SleuthKit.File.Path">
            <summary>
            The full path
            </summary>
        </member>
        <member name="T:SleuthKit.FileSystem">
            <summary>
            Stores state information for an open file system.   Roughly equivalent to the TSK_FS_INFO structure.
            </summary>
        </member>
        <member name="M:SleuthKit.FileSystem.#ctor(SleuthKit.DiskImage,SleuthKit.FileSystemType,System.Int64)">
            <summary>
            ctor for when there is no volume system (like thumb drives, floppies, etc. things with no MBR.. they just start with the filesystem)
            </summary>
            <param name="diskImage"></param>
            <param name="type"></param>
            <param name="offset"></param>
        </member>
        <member name="M:SleuthKit.FileSystem.#ctor(SleuthKit.Volume,SleuthKit.FileSystemType)">
            <summary>
            ctor for filesystem that comes from within a volume
            </summary>
            <param name="volume"></param>
            <param name="fstype"></param>
        </member>
        <member name="M:SleuthKit.FileSystem.OpenFile(System.String,SleuthKit.Directory)">
            <summary>
            Opens a file by path
            </summary>
            <param name="path"></param>
            <returns></returns>
        </member>
        <member name="M:SleuthKit.FileSystem.OpenFile(System.Int64,SleuthKit.Directory,System.String)">
            <summary>
            Opens a file by metadata address
            </summary>
            <param name="address"></param>
            <returns></returns>
        </member>
        <member name="M:SleuthKit.FileSystem.OpenDirectory(System.String,SleuthKit.Directory)">
            <summary>
            Opens a directory by path
            </summary>
            <param name="path"></param>
            <param name="parent"></param>
            <returns></returns>
        </member>
        <member name="M:SleuthKit.FileSystem.OpenDirectory(System.Int64,SleuthKit.Directory)">
            <summary>
            Opens a directory by metadata address
            </summary>
            <param name="address"></param>
            <param name="parent"></param>
            <returns></returns>
        </member>
        <member name="M:SleuthKit.FileSystem.OpenRootDirectory">
            <summary>
            Opens the root directory
            </summary>
            <returns></returns>
        </member>
        <member name="M:SleuthKit.FileSystem.OpenBlock(System.Int64)">
            <summary>
            Opens a block
            </summary>
            <param name="block"></param>
            <returns></returns>
        </member>
        <member name="M:SleuthKit.FileSystem.WalkMetadata(SleuthKit.MetaWalkDelegate,SleuthKit.MetadataFlags)">
            <summary>
            Walks metadata structures of the file system
            </summary>
            <param name="mwd">Meta Walk Delegate</param>
            <param name="flags">Meta data Flags</param>
            <returns>returns a byte value</returns>
        </member>
        <member name="M:SleuthKit.FileSystem.WalkDirectories(SleuthKit.DirWalkDelegate,SleuthKit.DirWalkFlags)">
            <summary>
            Walks the file names in a directory and obtain the details of the files via a callback.
            </summary>
            <param name="callback">
            Callback function that is called for each file name.
            </param>
            <param name="flags">
            Flags used during analysis.
            </param>
            <returns>
            Whether the operation is successful or not.
            </returns>
        </member>
        <member name="M:SleuthKit.FileSystem.Dispose">
            <summary>
            Releases resources
            </summary>
        </member>
        <member name="M:SleuthKit.FileSystem.ToString">
            <summary>
            diagnostic string
            </summary>
            <returns></returns>
        </member>
        <member name="P:SleuthKit.FileSystem.BlockSize">
            <summary>
            	Size of each block (in bytes) 
            </summary>
        </member>
        <member name="P:SleuthKit.FileSystem.BlockCount">
            <summary>
            Number of blocks in fs. 
            </summary>
        </member>
        <member name="P:SleuthKit.FileSystem.FirstBlock">
            <summary>
            Address of first block. 
            </summary>
        </member>
        <member name="P:SleuthKit.FileSystem.LastBlock">
            <summary>
            Address of last block as reported by file system (could be larger than last_block in image if end of image does not exist) 
            </summary>
        </member>
        <member name="P:SleuthKit.FileSystem.ActualLastBlock">
            <summary>
            Address of last block -- adjusted so that it is equal to the last block in the image or volume (if image is not complete) 
            </summary>
        </member>
        <member name="P:SleuthKit.FileSystem.Type">
            <summary>
            the filesystem type
            </summary>
        </member>
        <member name="P:SleuthKit.FileSystem.DiskImage">
            <summary>
            The image this filesystem comes from
            </summary>
        </member>
        <member name="T:SleuthKit.FileSystemBlock">
            <summary>
            Generic data strcture to hold block data with metadata
            </summary>
        </member>
        <member name="M:SleuthKit.FileSystemBlock.Dispose">
            <summary>
            Disposes resources
            </summary>
        </member>
        <member name="P:SleuthKit.FileSystemBlock.FileSystem">
            <summary>
            The filesystem
            </summary>
        </member>
        <member name="P:SleuthKit.FileSystemBlock.BlockAddress">
            <summary>
            The address of this block
            </summary>
        </member>
        <member name="P:SleuthKit.FileSystemBlock.Flags">
            <summary>
            The flags
            </summary>
        </member>
        <member name="T:SleuthKit.MetaDataExtractor">
            <summary>
            A class to extract meta data from E01 file
            </summary>
        </member>
        <member name="M:SleuthKit.MetaDataExtractor.Extract(System.String)">
            <summary>
            Extracts meta data of E01 at the time of development
            </summary>
            <param name="fileName">
            absolute file path
            </param>
            <returns>
            The <see cref="T:System.Collections.Generic.IDictionary`2"/>.
            </returns>
        </member>
        <member name="T:SleuthKit.NativeMethods">
            <summary>
            pinvoke
            </summary>
        </member>
        <member name="F:SleuthKit.NativeMethods.NativeLibrary">
            <summary>
            The framework should know to look for libtsk4.dll, libtsk4.so, libtsk3.dylib, depending on the OS.  It is that smart.
            </summary>
        </member>
        <member name="M:SleuthKit.NativeMethods.tsk_img_open(System.Int32,System.IntPtr[],SleuthKit.ImageType,System.UInt32)">
            extern TSK_IMG_INFO *tsk_img_open(int,const TSK_TCHAR * const images[], TSK_IMG_TYPE_ENUM, unsigned int a_ssize);
        </member>
        <member name="T:SleuthKit.DiskImageHandle">
            <summary>
            safe handle to work with TSK Disk Images (TSK_IMG_INFO*)
            </summary>
        </member>
        <member name="M:SleuthKit.DiskImageHandle.#ctor">
            <summary>
            ctor
            </summary>
        </member>
        <member name="M:SleuthKit.DiskImageHandle.ReleaseHandle">
            <summary>
            closes handle
            </summary>
            <returns></returns>
        </member>
        <member name="M:SleuthKit.DiskImageHandle.GetStruct">
            <summary>
            converts this pointer into an ImageInfo struct
            </summary>
            <returns></returns>
        </member>
        <member name="M:SleuthKit.DiskImageHandle.OpenVolumeSystemHandle(SleuthKit.VolumeSystemType,System.Int64)">
            <summary>
            Opens a new handle to a VolumeSystem of the specified type, at the specified offset.
            </summary>
            <param name="vstype"></param>
            <param name="offset"></param>
            <returns></returns>
        </member>
        <member name="M:SleuthKit.DiskImageHandle.OpenFileSystemHandle(SleuthKit.FileSystemType,System.Int64)">
            <summary>
            Opens a new Filesystem handle of the specified filesystem type, at the specified offset.
            </summary>
            <param name="fstype"></param>
            <param name="offset"></param>
            <returns></returns>
        </member>
        <member name="P:SleuthKit.DiskImageHandle.IsInvalid">
            <summary>
            invalid if pointer is zero
            </summary>
        </member>
        <member name="T:SleuthKit.VolumeSystemHandle">
            <summary>
            safe handle to work with TSK Volume Systems (TSK_VS_INFO*)
            </summary>
        </member>
        <member name="M:SleuthKit.VolumeSystemHandle.#ctor">
            <summary>
            ctor
            </summary>
        </member>
        <member name="M:SleuthKit.VolumeSystemHandle.ReleaseHandle">
            <summary>
            closes handle
            </summary>
            <returns></returns>
        </member>
        <member name="M:SleuthKit.VolumeSystemHandle.GetStruct">
            <summary>
            Converts this handle into a new VolumeSystemInfo.
            </summary>
            <returns></returns>
        </member>
        <member name="P:SleuthKit.VolumeSystemHandle.IsInvalid">
            <summary>
            invalid if pointer is zero
            </summary>
        </member>
        <member name="T:SleuthKit.FileSystemHandle">
            <summary>
            safe handle to work with TSK File Systems (TSK_FS_INFO*)
            </summary>
        </member>
        <member name="M:SleuthKit.FileSystemHandle.#ctor">
            <summary>
            ctor
            </summary>
        </member>
        <member name="M:SleuthKit.FileSystemHandle.ReleaseHandle">
            <summary>
            closes handle
            </summary>
            <returns></returns>
        </member>
        <member name="P:SleuthKit.FileSystemHandle.IsInvalid">
            <summary>
            invalid if pointer is zero
            </summary>
        </member>
        <member name="T:SleuthKit.FileSystemBlockHandle">
            <summary>
            safe handle to work with TSK File Systems (TSK_FS_BLOCK*)
            </summary>
        </member>
        <member name="M:SleuthKit.FileSystemBlockHandle.#ctor">
            <summary>
            ctor
            </summary>
        </member>
        <member name="M:SleuthKit.FileSystemBlockHandle.ReleaseHandle">
            <summary>
            closes handle
            </summary>
            <returns></returns>
        </member>
        <member name="P:SleuthKit.FileSystemBlockHandle.IsInvalid">
            <summary>
            invalid if pointer is zero
            </summary>
        </member>
        <member name="T:SleuthKit.FileHandle">
            <summary>
            safe handle to work with TSK File (TSK_FS_FILE*)
            </summary>
        </member>
        <member name="M:SleuthKit.FileHandle.#ctor">
            <summary>
            ctor
            </summary>
        </member>
        <member name="M:SleuthKit.FileHandle.ReleaseHandle">
            <summary>
            closes handle
            </summary>
            <returns></returns>
        </member>
        <member name="P:SleuthKit.FileHandle.IsInvalid">
            <summary>
            invalid if pointer is zero
            </summary>
        </member>
        <member name="T:SleuthKit.AttributeHandle">
            <summary>
            safe handle to work with TSK Attribute (TSK_FS_ATTR*)
            </summary>
        </member>
        <member name="M:SleuthKit.AttributeHandle.#ctor">
            <summary>
            ctor
            </summary>
        </member>
        <member name="M:SleuthKit.AttributeHandle.ReleaseHandle">
            <summary>
            closes handle
            </summary>
            <returns></returns>
        </member>
        <member name="P:SleuthKit.AttributeHandle.IsInvalid">
            <summary>
            invalid if pointer is zero
            </summary>
        </member>
        <member name="T:SleuthKit.DirectoryHandle">
            <summary>
            safe handle to work with TSK Directory (TSK_FS_DIR*)
            </summary>
        </member>
        <member name="M:SleuthKit.DirectoryHandle.#ctor">
            <summary>
            ctor
            </summary>
        </member>
        <member name="M:SleuthKit.DirectoryHandle.ReleaseHandle">
            <summary>
            closes handle
            </summary>
            <returns></returns>
        </member>
        <member name="P:SleuthKit.DirectoryHandle.IsInvalid">
            <summary>
            invalid if pointer is zero
            </summary>
        </member>
        <member name="T:SleuthKit.FileStream">
            <summary>
            Presents sleuthkit file content as a .NET BCL Stream.  Handy for interop with other libraries and the BCL itself.  
            </summary>
        </member>
        <member name="T:SleuthKit.BaseStream">
            <summary>
            Base class for other streams
            </summary>
        </member>
        <member name="F:SleuthKit.BaseStream.canRead">
            <summary>
            can be set by subclasses
            </summary>
        </member>
        <member name="F:SleuthKit.BaseStream.canWrite">
            <summary>
            can be set by subclasses
            </summary>
        </member>
        <member name="F:SleuthKit.BaseStream.canSeek">
            <summary>
            can be set by subclasses
            </summary>
        </member>
        <member name="F:SleuthKit.BaseStream.length">
            <summary>
            can be set by subclasses
            </summary>
        </member>
        <member name="F:SleuthKit.BaseStream.position">
            <summary>
            can be set by subclasses
            </summary>
        </member>
        <member name="M:SleuthKit.BaseStream.Flush">
            <summary>
            Flush this instance.
            </summary>
        </member>
        <member name="M:SleuthKit.BaseStream.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Read the specified buffer, offset and count.
            </summary>
            <param name='buffer'>
            Buffer.
            </param>
            <param name='offset'>
            Offset.
            </param>
            <param name='count'>
            Count.
            </param>
        </member>
        <member name="M:SleuthKit.BaseStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>
            Seek the specified offset and origin.
            </summary>
            <param name="offset">
            Offset.
            </param>
            <param name="origin">
            Origin.
            </param>
            <exception cref="T:System.ArgumentException">
            Is thrown when an argument passed to a method is invalid.
            </exception>
        </member>
        <member name="M:SleuthKit.BaseStream.SetLength(System.Int64)">
            <summary>
            Sets the length.
            </summary>
            <param name='value'> Value.</param> 
        </member>
        <member name="M:SleuthKit.BaseStream.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Write the specified buffer, offset and count.
            </summary>
            <param name='buffer'>
            Buffer.
            </param>
            <param name='offset'>
            Offset.
            </param>
            <param name='count'>
            Count.
            </param>
        </member>
        <member name="P:SleuthKit.BaseStream.CanRead">
            <summary>
            Gets a value indicating whether this instance can read.
            </summary>
            <value>
            <c>true</c> if this instance can read; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:SleuthKit.BaseStream.CanSeek">
            <summary>
            Gets a value indicating whether this instance can seek.
            </summary>
            <value>
            <c>true</c> if this instance can seek; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:SleuthKit.BaseStream.CanWrite">
            <summary>
            Gets a value indicating whether this instance can write.
            </summary>
            <value>
            <c>true</c> if this instance can write; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:SleuthKit.BaseStream.Length">
            <summary>
            Gets the length.
            </summary>
            <value>
            The length.
            </value>
        </member>
        <member name="P:SleuthKit.BaseStream.Position">
            <summary>
            Gets or sets the position.
            </summary>
            <value>
            The position.
            </value>
        </member>
        <member name="M:SleuthKit.FileStream.#ctor(SleuthKit.File)">
            <summary>
            ctor
            </summary>
            <param name="file"></param>
        </member>
        <member name="T:SleuthKit.DiskImageStream">
            <summary>
            Presents sleuthkit disk content as a .NET BCL Stream.  Handy for interop with other libraries and the BCL itself.  
            </summary>
        </member>
        <member name="M:SleuthKit.DiskImageStream.#ctor(SleuthKit.DiskImage)">
            <summary>
            ctor
            </summary>
            <param name="disk"></param>
        </member>
        <member name="F:SleuthKit.Structs.HFS_ENTRY.flags">
            <summary>
            flags for on-disk record
            </summary>
        </member>
        <member name="F:SleuthKit.Structs.HFS_ENTRY.inum">
            <summary>
            cnid
            </summary>
        </member>
        <member name="F:SleuthKit.Structs.HFS_ENTRY.thread">
            <summary>
            thread record
            </summary>
        </member>
        <member name="F:SleuthKit.Structs.hfs_thread.rec_type">
            <summary>
            == kHFSPlusFolderThreadRecord or kHFSPlusFileThreadRecord
            </summary>
        </member>
        <member name="F:SleuthKit.Structs.hfs_thread.res">
            <summary>
            reserved - initialized as zero
            </summary>
        </member>
        <member name="F:SleuthKit.Structs.hfs_thread.parent_cnid">
            <summary>
            parent ID for this catalog node
            </summary>
        </member>
        <member name="F:SleuthKit.Structs.hfs_thread.name">
            <summary>
            name of this catalog node (variable length)
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "F:SleuthKit.Structs.TSK_FS_ATTR_RUN.offset" -->
        <!-- Badly formed XML comment ignored for member "F:SleuthKit.Structs.TSK_FS_ATTR_RUN.addr" -->
        <!-- Badly formed XML comment ignored for member "F:SleuthKit.Structs.TSK_FS_ATTR_RUN.len" -->
        <!-- Badly formed XML comment ignored for member "F:SleuthKit.Structs.TSK_FS_ATTR_RUN.flags" -->
        <!-- Badly formed XML comment ignored for member "P:SleuthKit.Structs.TSK_FS_ATTR_RUN.HasNext" -->
        <member name="T:SleuthKit.Structs.TSK_FS_DIR">
            <summary>
            TSK_FS_DIR
            </summary>
        </member>
        <member name="F:SleuthKit.Structs.TSK_FS_DIR.address">
            <summary>
            Metadata address of this directory 
            </summary>
        </member>
        <member name="P:SleuthKit.Structs.TSK_FS_DIR.AppearsValid">
            <summary>
            Verifies tag
            </summary>
        </member>
        <member name="F:SleuthKit.Structs.FATFS_INFO.sb_ptr">
            <summary>
            super block
            </summary>
        </member>
        <member name="T:SleuthKit.Structs.TSK_FS_META">
            <summary>
            represents TSK_FS_META
            </summary>
        </member>
        <member name="F:SleuthKit.Structs.TSK_FS_META.tag">
            <summary>
            tag, can be used to validate that we have the right kind of struct.  a magic header for the struct, essentially.
            </summary>
        </member>
        <member name="F:SleuthKit.Structs.TSK_FS_META.flags">
            <summary>
            Flags for this file for its allocation status etc.
            </summary>
        </member>
        <member name="F:SleuthKit.Structs.TSK_FS_META.addr">
            <summary>
            Address of the meta data structure for this file
            </summary>
        </member>
        <member name="F:SleuthKit.Structs.TSK_FS_META.type">
            <summary>
            File type
            </summary>
        </member>
        <member name="F:SleuthKit.Structs.TSK_FS_META.mode">
            <summary>
            Unix-style permissions
            </summary>
        </member>
        <member name="F:SleuthKit.Structs.TSK_FS_META.nlink">
            <summary>
            link count (number of file names pointing to this)
            </summary>
        </member>
        <member name="F:SleuthKit.Structs.TSK_FS_META.size">
            <summary>
            file size (in bytes) - yes this is a signed 64-bit integer, despite it being unsigned in sleuthkit (?).  It is easier this way.
            </summary>
        </member>
        <member name="F:SleuthKit.Structs.TSK_FS_META.uid">
            <summary>
            user id
            </summary>
        </member>
        <member name="F:SleuthKit.Structs.TSK_FS_META.gid">
            <summary>
            group id
            </summary>
        </member>
        <member name="F:SleuthKit.Structs.TSK_FS_META.mtime">
            <summary>
            last file content modification time (stored in number of seconds since Jan 1, 1970 UTC)
            </summary>
        </member>
        <member name="F:SleuthKit.Structs.TSK_FS_META.mtime_nano">
            <summary>
            nano-second resolution in addition to m_time
            </summary>
        </member>
        <member name="F:SleuthKit.Structs.TSK_FS_META.atime">
            <summary>
            last file content accessed time (stored in number of seconds since Jan 1, 1970 UTC)
            </summary>
        </member>
        <member name="F:SleuthKit.Structs.TSK_FS_META.atime_nano">
            <summary>
            nano-second resolution in addition to a_time
            </summary>
        </member>
        <member name="F:SleuthKit.Structs.TSK_FS_META.ctime">
            <summary>
             last file / metadata status change time (stored in number of seconds since Jan 1, 1970 UTC)
            </summary>
        </member>
        <member name="F:SleuthKit.Structs.TSK_FS_META.ctime_nano">
            <summary>
            nano-second resolution in addition to c_time
            </summary>
        </member>
        <member name="F:SleuthKit.Structs.TSK_FS_META.crtime">
            <summary>
            Created time (stored in number of seconds since Jan 1, 1970 UTC)
            </summary>
        </member>
        <member name="F:SleuthKit.Structs.TSK_FS_META.crtime_nano">
            <summary>
            nano-second resolution in addition to cr_time
            </summary>
        </member>
        <member name="F:SleuthKit.Structs.TSK_FS_META.content_ptr">
            <summary>
            Pointer to file system specific data that is used to store references to file content
            </summary>
        </member>
        <member name="F:SleuthKit.Structs.TSK_FS_META.content_len">
            <summary>
            size of content  buffer
            </summary>
        </member>
        <member name="F:SleuthKit.Structs.TSK_FS_META.content_type">
            <summary>
            The content type
            </summary>
        </member>
        <member name="F:SleuthKit.Structs.TSK_FS_META.seq">
            <summary>
            Sequence number for file (NTFS only, is incremented when entry is reallocated) 
            </summary>
        </member>
        <member name="F:SleuthKit.Structs.TSK_FS_META.attr_ptr">
            <summary>
            Contains run data on the file content (specific locations where content is stored).  
            Check attr_state to determine if data in here is valid because not all file systems 
            load this data when a file is loaded.  It may not be loaded until needed by one
            of the APIs. Most file systems will have only one attribute, but NTFS will have several. 
            </summary>
        </member>
        <member name="F:SleuthKit.Structs.TSK_FS_META.attr_state">
            <summary>
            State of the data in the TSK_FS_META::attr structure
            </summary>
        </member>
        <member name="F:SleuthKit.Structs.TSK_FS_META.name2">
            <summary>
            Name of file stored in metadata (FAT and NTFS Only)
            </summary>
        </member>
        <member name="F:SleuthKit.Structs.TSK_FS_META.link">
            <summary>
            Name of target file if this is a symbolic link
            </summary>
        </member>
        <member name="P:SleuthKit.Structs.TSK_FS_META.AppearsValid">
            <summary>
            validates the tag contains the proper constant
            </summary>
        </member>
        <member name="P:SleuthKit.Structs.TSK_FS_META.Address">
            <summary>
            Metadata Address
            </summary>
        </member>
        <member name="P:SleuthKit.Structs.TSK_FS_META.MetadataFlags">
            <summary>
            Metadata flags
            </summary>
        </member>
        <member name="P:SleuthKit.Structs.TSK_FS_META.MetadataType">
            <summary>
            Metadata type
            </summary>
        </member>
        <member name="P:SleuthKit.Structs.TSK_FS_META.Size">
            <summary>
            File size, in bytes
            </summary>
        </member>
        <member name="P:SleuthKit.Structs.TSK_FS_META.MTime">
            <summary>
            Modified time in unix epoch ticks
            </summary>
        </member>
        <member name="P:SleuthKit.Structs.TSK_FS_META.ATime">
            <summary>
            Access time in unix epoch ticks
            </summary>
        </member>
        <member name="P:SleuthKit.Structs.TSK_FS_META.CTime">
            <summary>
            Metadata change time in unix epoch ticks
            </summary>
        </member>
        <member name="P:SleuthKit.Structs.TSK_FS_META.CRTime">
            <summary>
            Kreayshawn time in unix epoch ticks
            </summary>
        </member>
        <member name="T:SleuthKit.Structs.TSK_FS_FILE">
            <summary>
            represents TSK_FS_FILE.  Generic structure used to refer to files in the file system.  A file will typically have a name and metadata.  This structure holds that type of information.
            When deleted files are being processed, this structure may have the name defined but not metadata because it no longer exists. 
            </summary>
        </member>
        <member name="F:SleuthKit.Structs.TSK_FS_FILE.tag">
            <summary>
            tag, can be used to validate that we have the right kind of struct.  a magic header for the struct, essentially.
            </summary>
        </member>
        <member name="F:SleuthKit.Structs.TSK_FS_FILE.ptr_filename">
            <summary>
            pointer to filename struct - or null if file was opened using metadata address
            </summary>
        </member>
        <member name="F:SleuthKit.Structs.TSK_FS_FILE.ptr_meta">
            <summary>
            Pointer to metadata of file (or NULL if name has invalid metadata address)
            </summary>
        </member>
        <member name="F:SleuthKit.Structs.TSK_FS_FILE.ptr_fsinfo">
            <summary>
            Pointer to file system that the file is located in.
            </summary>
        </member>
        <member name="P:SleuthKit.Structs.TSK_FS_FILE.Name">
            <summary>
            filename
            </summary>
        </member>
        <member name="P:SleuthKit.Structs.TSK_FS_FILE.Metadata">
            <summary>
            metadata
            </summary>
        </member>
        <member name="P:SleuthKit.Structs.TSK_FS_FILE.AppearsValid">
            <summary>
            validates the tag contains the proper constant
            </summary>
        </member>
        <member name="T:SleuthKit.Structs.TSK_FS_BLOCK">
            <summary>
            struct TSK_FS_BLOCK
            </summary>
        </member>
        <member name="F:SleuthKit.Structs.TSK_FS_BLOCK.tag">
            <summary>
            internal Will be set to TSK_FS_BLOCK_TAG if structure is valid / allocated 
            </summary>
        </member>
        <member name="F:SleuthKit.Structs.TSK_FS_BLOCK.ptr_fs_info">
             <summary>
            Pointer to file system that block is from
             </summary>
        </member>
        <member name="F:SleuthKit.Structs.TSK_FS_BLOCK.ptr_block_data">
            <summary>
             Buffer with block data (of size TSK_FS_INFO::block_size)
            </summary>
        </member>
        <member name="F:SleuthKit.Structs.TSK_FS_BLOCK.addr">
            <summary>
            Address of block
            </summary>
        </member>
        <member name="F:SleuthKit.Structs.TSK_FS_BLOCK.flags">
            <summary>
            Flags for block (alloc or unalloc)
            </summary>
        </member>
        <member name="P:SleuthKit.Structs.TSK_FS_BLOCK.AppearsValid">
            <summary>
            validates the tag contains the proper constant
            </summary>
        </member>
        <member name="T:SleuthKit.Structs.TSK_FS_INFO">
            <summary>
            struct TSK_FS_INFO
            </summary>
        </member>
        <member name="F:SleuthKit.Structs.TSK_FS_INFO.tag">
            <summary>
            tag, can be used to validate that we have the right kind of struct.  a magic header for the struct, essentially.
            </summary>
        </member>
        <member name="F:SleuthKit.Structs.TSK_FS_INFO.img_info_ptr">
            <summary>
            pointer to imageinfo struct
            </summary>
        </member>
        <member name="F:SleuthKit.Structs.TSK_FS_INFO.offset">
            <summary>
            TSK_OFF_T offset, Byte offset into img_info that fs starts 
            </summary>
        </member>
        <member name="F:SleuthKit.Structs.TSK_FS_INFO.inum_count">
            <summary>
            number of metadata addresses
            </summary>
        </member>
        <member name="F:SleuthKit.Structs.TSK_FS_INFO.root_inum">
            <summary>
            address of root directory
            </summary>
        </member>
        <member name="F:SleuthKit.Structs.TSK_FS_INFO.first_inum">
            <summary>
            address of first metadata
            </summary>
        </member>
        <member name="F:SleuthKit.Structs.TSK_FS_INFO.last_inum">
            <summary>
            address of last metadata
            </summary>
        </member>
        <member name="F:SleuthKit.Structs.TSK_FS_INFO.block_count">
            <summary>
            Number of blocks in fs
            </summary>
        </member>
        <member name="F:SleuthKit.Structs.TSK_FS_INFO.first_block">
            <summary>
            Address of first block
            </summary>
        </member>
        <member name="F:SleuthKit.Structs.TSK_FS_INFO.last_block">
            <summary>
            Address of last block as reported by file system (could be larger than last_block in image if end of image does not exist)
            </summary>
            
        </member>
        <member name="F:SleuthKit.Structs.TSK_FS_INFO.last_block_act">
            <summary>
            Address of last block -- adjusted so that it is equal to the last block in the image or volume (if image is not complete)
            </summary>
        </member>
        <member name="F:SleuthKit.Structs.TSK_FS_INFO.block_size">
            <summary>
            Size of each block (in bytes)
            </summary>
        </member>
        <member name="F:SleuthKit.Structs.TSK_FS_INFO.dev_bsize">
            <summary>
            Size of device block (typically always 512)
            </summary>
        </member>
        <member name="F:SleuthKit.Structs.TSK_FS_INFO.block_pre_size">
            <summary>
            Number of bytes that preceed each block (currently only used for RAW CDs)
            </summary>
        </member>
        <member name="F:SleuthKit.Structs.TSK_FS_INFO.block_post_size">
            <summary>
            Number of bytes that follow each block (currently only used for RAW CDs)
            </summary>
        </member>
        <member name="F:SleuthKit.Structs.TSK_FS_INFO.journ_inum">
            <summary>
            Address of journal inode
            </summary>
        </member>
        <member name="F:SleuthKit.Structs.TSK_FS_INFO.ftype">
            <summary>
            type of file system 
            </summary>
        </member>
        <member name="F:SleuthKit.Structs.TSK_FS_INFO.duname_ptr">
            <summary>
            string "name" of data unit type 
            </summary>
        </member>
        <member name="F:SleuthKit.Structs.TSK_FS_INFO.flags">
            <summary>
            flags
            </summary>
        </member>
        <member name="F:SleuthKit.Structs.TSK_FS_INFO.fs_id_ptr">
            <summary>
            File system id (as reported in boot sector)
            </summary>
        </member>
        <member name="F:SleuthKit.Structs.TSK_FS_INFO.fs_id_used">
            <summary>
            fs id used
            </summary>
        </member>
        <member name="F:SleuthKit.Structs.TSK_FS_INFO.list_inum_named_lock">
            <summary>
            taken when r/w the list_inum_named list
            </summary>
        </member>
        <member name="F:SleuthKit.Structs.TSK_FS_INFO.list_inum_named_ptr">
            <summary>
            List of unallocated inodes that
            </summary>
        </member>
        <member name="F:SleuthKit.Structs.TSK_FS_INFO.orphan_dir_lock">
            <summary>
            taken for the duration of orphan hunting (not just when updating orphan_dir)
            </summary>
        </member>
        <member name="F:SleuthKit.Structs.TSK_FS_INFO.orphan_dir_ptr">
            <summary>
            Files and dirs in the top level of the $OrphanFiles directory.  NULL if orphans have not been hunted for yet. 
            </summary>
        </member>
        <member name="P:SleuthKit.Structs.TSK_FS_INFO.ID">
            <summary>
            Returns nothing at the moment
            </summary>
        </member>
        <member name="P:SleuthKit.Structs.TSK_FS_INFO.AppearsValid">
            <summary>
            validates the tag contains the proper constant
            </summary>
        </member>
        <member name="P:SleuthKit.Structs.TSK_FS_INFO.ImageInfo">
            <summary>
            Image information
            </summary>
        </member>
        <member name="P:SleuthKit.Structs.TSK_FS_INFO.Offset">
            <summary>
            the offset where the filesystem starts
            </summary>
        </member>
        <member name="P:SleuthKit.Structs.TSK_FS_INFO.FilesystemType">
            <summary>
            the type of filesystem
            </summary>
        </member>
        <member name="F:SleuthKit.Structs.EXT2FS_INFO.fs_info">
            <summary>
            super class
            </summary>
        </member>
        <member name="F:SleuthKit.Structs.EXT2FS_INFO.fs_ptr">
            <summary>
            super block
            </summary>
        </member>
        <member name="F:SleuthKit.Structs.EXT2FS_INFO.s_lock">
            <summary>
            lock protects grp_buf, grp_num, bmap_buf, bmap_grp_num, imap_buf, imap_grp_num
            </summary>
        </member>
        <member name="F:SleuthKit.Structs.EXT2FS_INFO.grp_buf_ptr">
            <summary>
            cached group descriptor r/w shared - lock
            </summary>
        </member>
        <member name="F:SleuthKit.Structs.EXT2FS_INFO.grp_num">
            <summary>
            cached group number r/w shared - lock
            </summary>
        </member>
        <member name="F:SleuthKit.Structs.EXT2FS_INFO.bmap_buf_ptr">
            <summary>
            cached block allocation bitmap r/w shared - lock
            </summary>
        </member>
        <member name="F:SleuthKit.Structs.EXT2FS_INFO.bmap_grp_num">
            <summary>
            cached block bitmap nr r/w shared - lock
            </summary>
        </member>
        <member name="F:SleuthKit.Structs.EXT2FS_INFO.imap_buf_ptr">
            <summary>
            cached inode allocation bitmap r/w shared - lock
            </summary>
        </member>
        <member name="F:SleuthKit.Structs.EXT2FS_INFO.imap_grp_num">
            <summary>
            cached inode bitmap nr r/w shared - lock
            </summary>
        </member>
        <member name="F:SleuthKit.Structs.EXT2FS_INFO.groups_offset">
            <summary>
            offset to first group desc
            </summary>
        </member>
        <member name="F:SleuthKit.Structs.EXT2FS_INFO.groups_count">
            <summary>
            nr of descriptor group blocks
            </summary>
        </member>
        <member name="F:SleuthKit.Structs.EXT2FS_INFO.deentry_type">
            <summary>
            v1 or v2 of dentry
            </summary>
        </member>
        <member name="F:SleuthKit.Structs.EXT2FS_INFO.inode_size">
            <summary>
            size of each inode
            </summary>
        </member>
        <member name="T:SleuthKit.Structs.TSK_IMG_INFO">
            <summary>
            represents TSK_IMG_INFO
            </summary>
        </member>
        <member name="F:SleuthKit.Structs.TSK_IMG_INFO.tag">
            <summary>
            Set to TSK_IMG_INFO_TAG when struct is alloc
            </summary>
        </member>
        <member name="F:SleuthKit.Structs.TSK_IMG_INFO.itype">
            <summary>
            Type of disk image format
            </summary>
        </member>
        <member name="F:SleuthKit.Structs.TSK_IMG_INFO.size">
            <summary>
            Total size of image in bytes
            </summary>
        </member>
        <member name="F:SleuthKit.Structs.TSK_IMG_INFO.sector_size">
            <summary>
            sector size of device in bytes (typically 512)
            </summary>
        </member>
        <member name="F:SleuthKit.Structs.TSK_IMG_INFO.page_size">
            <summary>
            page size of NAND page in bytes (defaults to 2048)
            </summary>
        </member>
        <member name="F:SleuthKit.Structs.TSK_IMG_INFO.spare_size">
            <summary>
            spare or OOB size of NAND in bytes (defaults to 64)
            </summary>
        </member>
        <member name="F:SleuthKit.Structs.TSK_IMG_INFO.cacheLock">
            <summary>
            Place holder for lock of cache and associated values
            </summary>
        </member>
        <member name="P:SleuthKit.Structs.TSK_IMG_INFO.IsInitialized">
            <summary>
            Checks that size and sector_size are non-zero.
            </summary>
        </member>
        <member name="T:SleuthKit.Structs.TSK_FS_NAME">
            <summary>
            TSK_FS_NAME Generic structure to store the file name information that is stored in a directory. Most file systems seperate the file name from the metadata, but some do not (such as FAT). This structure contains the name and address of the metadata.
            </summary>
        </member>
        <member name="F:SleuthKit.Structs.TSK_FS_NAME.tag">
            <summary>
            tag, can be used to validate that we have the right kind of struct. a magic header for the struct, essentially.
            </summary>
        </member>
        <member name="F:SleuthKit.Structs.TSK_FS_NAME.ptr_name">
            <summary>
            The name of the file (in UTF-8)
            </summary>
        </member>
        <member name="F:SleuthKit.Structs.TSK_FS_NAME.name_size">
            <summary>
            The number of bytes allocated to name
            </summary>
        </member>
        <member name="F:SleuthKit.Structs.TSK_FS_NAME.ptr_short_name">
            <summary>
            The short name of the file or null (in UTF-8)
            </summary>
        </member>
        <member name="F:SleuthKit.Structs.TSK_FS_NAME.short_name_size">
            <summary>
            The number of bytes allocated to shrt_name
            </summary>
        </member>
        <member name="F:SleuthKit.Structs.TSK_FS_NAME.meta_addr">
            <summary>
            Address of the metadata structure that the name points to. 
            </summary>
        </member>
        <member name="F:SleuthKit.Structs.TSK_FS_NAME.meta_seq">
            <summary>
            Sequence number for metadata structure (NTFS only) 
            </summary>
        </member>
        <member name="F:SleuthKit.Structs.TSK_FS_NAME.par_addr">
            <summary>
            Metadata address of parent directory (equal to meta_addr if this entry is for root directory). 
            </summary>
        </member>
        <member name="F:SleuthKit.Structs.TSK_FS_NAME.par_seq">
            <summary>
            Sequence number for parent directory (NTFS only)
            </summary>
        </member>
        <member name="F:SleuthKit.Structs.TSK_FS_NAME.type">
            <summary>
            File type information (directory, file, etc.)
            </summary>
        </member>
        <member name="F:SleuthKit.Structs.TSK_FS_NAME.flags">
            <summary>
            Flags that describe allocation status etc. 
            </summary>
        </member>
        <member name="M:SleuthKit.Structs.TSK_FS_NAME.GetName">
            <summary>
            returns the long name or short name, depending on whats available.
            </summary>
            <returns></returns>
        </member>
        <member name="M:SleuthKit.Structs.TSK_FS_NAME.ToString">
            <summary>
            Prints out the name, long name first, if it is null then it tries short name.
            </summary>
            <returns></returns>
        </member>
        <member name="P:SleuthKit.Structs.TSK_FS_NAME.AppearsValid">
            <summary>
            validates the tag contains the proper constant
            </summary>
        </member>
        <member name="P:SleuthKit.Structs.TSK_FS_NAME.LongName">
            <summary>
            The filename
            </summary>
        </member>
        <member name="P:SleuthKit.Structs.TSK_FS_NAME.ShortName">
            <summary>
            The short name, if any
            </summary>
        </member>
        <member name="T:SleuthKit.Structs.tsk_lock_t">
            <summary>
            Dummy struct as a placeholder for tsk_lock_t struct in TSK 
            </summary>
        </member>
        <member name="F:SleuthKit.Structs.tsk_lock_t.placeholder1">
            <summary>
            The placeholder1.
            </summary>
        </member>
        <member name="F:SleuthKit.Structs.tsk_lock_t.placeholder2">
            <summary>
            The placeholder2
            </summary>
        </member>
        <member name="F:SleuthKit.Structs.tsk_lock_t.placeholder3">
            <summary>
            The placeholder3
            </summary>
        </member>
        <member name="F:SleuthKit.Structs.tsk_lock_t.placeholder4">
            <summary>
            The placeholder4
            </summary>
        </member>
        <member name="F:SleuthKit.Structs.tsk_lock_t.placeholder5">
            <summary>
            The placeholder5
            </summary>
        </member>
        <member name="F:SleuthKit.Structs.tsk_lock_t.placeholder6">
            <summary>
            The placeholder6
            </summary>
        </member>
        <member name="T:SleuthKit.ProcessVolumeDelegate">
            <summary>
            Called when processing a filesystem
            </summary>
            <param name="tskFilesystem"></param>
            <returns></returns>
        </member>
        <member name="T:SleuthKit.ProcessFilesystemDelegate">
            <summary>
            Called when processing a filesystem
            </summary>
            <param name="tskFilesystem"></param>
            <returns></returns>
        </member>
        <member name="T:SleuthKit.ProcessFileDelegate">
            <summary>
            Called when processing a file
            </summary>
            <param name="tskFile"></param>
            <param name="path"></param>
            <returns></returns>
        </member>
        <member name="T:SleuthKit.MetaWalkDelegate">
            <summary>
            Called for each metdata entry during a metadata walk
            typedef TSK_WALK_RET_ENUM(* TSK_FS_META_WALK_CB)(TSK_FS_FILE *a_fs_file, void *a_ptr)
            </summary>
            <param name="file"></param>
            <param name="some_ptr"></param>
            <returns></returns>
        </member>
        <member name="T:SleuthKit.FileContentWalkDelegate">
            <summary>
            Callback function that is called for file content during file walk. (TSK_FS_FILE_WALK_CB)
            </summary>
            <param name="file">The file.</param>
            <param name="offset">The offset.</param>
            <param name="address">The address.</param>
            <param name="buffer">The data buffer.</param>
            <param name="length">The length.</param>
            <param name="flags">The flags.</param>
            <param name="dataPtr">Pointer to data that is passed to the callback function each time.</param>
            <returns>Value to control the file walk.</returns>
        </member>
        <member name="F:SleuthKit.Structs.TSK_FS_META_NAME_LIST.next">
            <summary>
            Pointer to next name (or NULL)
            </summary>
        </member>
        <member name="F:SleuthKit.Structs.TSK_FS_META_NAME_LIST.name">
            <summary>
            Name in UTF-8 (does not include parent directory name)
            </summary>
        </member>
        <member name="F:SleuthKit.Structs.TSK_FS_META_NAME_LIST.par_inode">
            <summary>
            Inode address of parent directory (NTFS only)
            </summary>
        </member>
        <member name="F:SleuthKit.Structs.TSK_FS_META_NAME_LIST.par_seq">
            <summary>
            Sequence number of parent directory (NTFS only)
            </summary>
        </member>
        <member name="T:SleuthKit.Structs.TSK_VS_PART_INFO">
            <summary>
            TSK_VS_PART_INFO
            </summary>
        </member>
        <member name="F:SleuthKit.Structs.TSK_VS_PART_INFO.tag">
            <summary>
            Tag of TSK_VS_PART_INFO
            </summary>
        </member>
        <member name="F:SleuthKit.Structs.TSK_VS_PART_INFO.ptr_prev_part">
            <summary>
            Pointer to previous partition (or NULL)
            </summary>
        </member>
        <member name="F:SleuthKit.Structs.TSK_VS_PART_INFO.ptr_next_part">
            <summary>
            Pointer to next partition (or NULL)
            </summary>
        </member>
        <member name="F:SleuthKit.Structs.TSK_VS_PART_INFO.ptr_vs_info">
            <summary>
            Pointer to parent volume system handle
            </summary>
        </member>
        <member name="F:SleuthKit.Structs.TSK_VS_PART_INFO.start">
            <summary>
            Sector offset of start of partition
            </summary>
        </member>
        <member name="F:SleuthKit.Structs.TSK_VS_PART_INFO.len">
            <summary>
            Number of sectors in partition
            </summary>
        </member>
        <member name="F:SleuthKit.Structs.TSK_VS_PART_INFO.ptr_utf8desc">
            <summary>
             UTF-8 description of partition (volume system type-specific)
            </summary>
        </member>
        <member name="F:SleuthKit.Structs.TSK_VS_PART_INFO.table_num">
            <summary>
            Table address that describes this partition
            </summary>
        </member>
        <member name="F:SleuthKit.Structs.TSK_VS_PART_INFO.slot_num">
            <summary>
            Entry in the table that describes this partition
            </summary>
        </member>
        <member name="F:SleuthKit.Structs.TSK_VS_PART_INFO.addr">
            <summary>
            Address of this partition
            </summary>
        </member>
        <member name="F:SleuthKit.Structs.TSK_VS_PART_INFO.flags">
            <summary>
            Flags for partition
            </summary>
        </member>
        <member name="P:SleuthKit.Structs.TSK_VS_PART_INFO.SectorOffset">
            <summary>
            Sector offset of start of partition. 
            </summary>
        </member>
        <member name="P:SleuthKit.Structs.TSK_VS_PART_INFO.SectorLength">
            <summary>
            Size in bytes of this volume
            </summary>
        </member>
        <member name="P:SleuthKit.Structs.TSK_VS_PART_INFO.TableNumber">
            <summary>
            Table address that describes this partition. 
            </summary>
        </member>
        <member name="P:SleuthKit.Structs.TSK_VS_PART_INFO.SlotNumber">
            <summary>
            Table address that describes this partition. 
            </summary>
        </member>
        <member name="P:SleuthKit.Structs.TSK_VS_PART_INFO.Address">
            <summary>
            Address of this partition
            </summary>
        </member>
        <member name="P:SleuthKit.Structs.TSK_VS_PART_INFO.Flags">
            <summary>
            Flags.. what more can you say?
            </summary>
        </member>
        <member name="P:SleuthKit.Structs.TSK_VS_PART_INFO.Next">
            <summary>
            Next volume, if any
            </summary>
        </member>
        <member name="P:SleuthKit.Structs.TSK_VS_PART_INFO.Previous">
            <summary>
            Previous volume, if any
            </summary>
        </member>
        <member name="P:SleuthKit.Structs.TSK_VS_PART_INFO.Description">
            <summary>
            Volume description
            </summary>
        </member>
        <member name="T:SleuthKit.Structs.TSK_VS_INFO">
            <summary>
            represents TSK_VS_INFO.  Data structure used to store state and basic information for open volume systems.
            </summary>
        </member>
        <member name="F:SleuthKit.Structs.TSK_VS_INFO.tag">
            <summary>
            Will be set to TSK_VS_INFO_TAG if structure is still allocated.
            </summary>
        </member>
        <member name="F:SleuthKit.Structs.TSK_VS_INFO.ptr_imageInfo">
            <summary>
            Pointer to disk image that VS is in
            </summary>
        </member>
        <member name="F:SleuthKit.Structs.TSK_VS_INFO.vstype">
            <summary>
            Type of volume system / media management
            </summary>
        </member>
        <member name="F:SleuthKit.Structs.TSK_VS_INFO.offset">
            <summary>
            Byte offset where VS starts in disk image
            </summary>
        </member>
        <member name="F:SleuthKit.Structs.TSK_VS_INFO.block_size">
            <summary>
            Size of blocks in bytes
            </summary>
        </member>
        <member name="F:SleuthKit.Structs.TSK_VS_INFO.endian">
            <summary>
            Endian ordering of data
            </summary>
        </member>
        <member name="F:SleuthKit.Structs.TSK_VS_INFO.ptr_first_volumeinfo">
            <summary>
            Linked list of partitions
            </summary>
        </member>
        <member name="F:SleuthKit.Structs.TSK_VS_INFO.part_count">
            <summary>
            number of partitions 
            </summary>
        </member>
        <member name="P:SleuthKit.Structs.TSK_VS_INFO.Offset">
            <summary>
            The offset to the start of this volume system
            </summary>
        </member>
        <member name="P:SleuthKit.Structs.TSK_VS_INFO.Type">
            <summary>
            The type of volume system (MBR, APM, GPT, etc)
            </summary>
        </member>
        <member name="P:SleuthKit.Structs.TSK_VS_INFO.Endianness">
            <summary>
            The endianness of this volume system (little, big, etc)
            </summary>
        </member>
        <member name="P:SleuthKit.Structs.TSK_VS_INFO.PartitionCount">
            <summary>
            The number of partitions on this volume system
            </summary>
        </member>
        <member name="P:SleuthKit.Structs.TSK_VS_INFO.BlockSize">
            <summary>
            The number of blocks
            </summary>
        </member>
        <member name="P:SleuthKit.Structs.TSK_VS_INFO.FirstVolumeInfo">
            <summary>
            First volume info
            </summary>
        </member>
        <member name="P:SleuthKit.Structs.TSK_VS_INFO.VolumeInfos">
            <summary>
            All volume infos
            </summary>
        </member>
        <member name="T:SleuthKit.UTF8Marshaler">
            <summary>
            Marshals unmanaged UTF8 string to and from System.String.
            </summary>
        </member>
        <member name="T:SleuthKit.ObjectDumper">
            <summary>
            Useful for printing out objects.
            </summary>
        </member>
        <member name="T:SleuthKit.IntPtrExtensions">
            <summary>
            Helpful methods for IntPtr
            </summary>
        </member>
        <member name="M:SleuthKit.IntPtrExtensions.Increment(System.IntPtr,System.Int32)">
            <summary>
            Advances position of the pointer
            </summary>
            <param name="ptr"></param>
            <param name="cbSize"></param>
            <returns></returns>
        </member>
        <member name="M:SleuthKit.IntPtrExtensions.Increment``1(System.IntPtr)">
            <summary>
            Increments by the size of the structure or object.  Calls <c>Marshal.SizeOf(typeof(T))</c> on what you pass in.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="ptr"></param>
            <returns></returns>
        </member>
        <member name="M:SleuthKit.IntPtrExtensions.ElementAt``1(System.IntPtr,System.Int32)">
            <summary>
            Treats the pointer like the start of an array, and allows you to fetch item at the specified index.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="ptr"></param>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="T:SleuthKit.Volume">
            <summary>
            TSK_VS_PART_INFO structure is used to describe each volume. This structure has fields for the volume starting offset (relative to the start of the disk image), length, and type.
            </summary>
        </member>
        <member name="M:SleuthKit.Volume.#ctor(SleuthKit.VolumeSystem,System.IntPtr)">
            <summary>
            ctor, for internal use only
            </summary>
            <param name="volumeSystem"></param>
            <param name="ptrToVolumeInfo"></param>
        </member>
        <member name="M:SleuthKit.Volume.OpenFileSystem(SleuthKit.FileSystemType)">
            <summary>
            Opens the filesystem on this volume, if any
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:SleuthKit.Volume.ToString">
            <summary>
            A human-friendly description of the volume
            </summary>
            <returns></returns>
        </member>
        <member name="P:SleuthKit.Volume.VolumeSystem">
            <summary>
            The volume system that this partition came from
            </summary>
        </member>
        <member name="P:SleuthKit.Volume.Description">
            <summary>
            Description
            </summary>
        </member>
        <member name="P:SleuthKit.Volume.Flags">
            <summary>
            Flags
            </summary>
        </member>
        <member name="P:SleuthKit.Volume.IsAllocated">
            <summary>
            Is allocated? <c>(Flags &amp; VolumeFlags.Allocated) != 0</c>
            </summary>
        </member>
        <member name="P:SleuthKit.Volume.Offset">
            <summary>
            The offset in bytes of the start of the partition
            </summary>
        </member>
        <member name="P:SleuthKit.Volume.Length">
            <summary>
            The length in bytes of this partition
            </summary>
        </member>
        <member name="P:SleuthKit.Volume.SectorOffset">
            <summary>
            Sector offset of start of partition. 
            </summary>
        </member>
        <member name="P:SleuthKit.Volume.SectorLength">
            <summary>
            Sector length of start of partition. 
            </summary>
        </member>
        <member name="P:SleuthKit.Volume.Address">
            <summary>
            Address of this partition
            </summary>
        </member>
        <member name="T:SleuthKit.VolumeSystem">
            <summary>
            Represents a volume system.  Volume systems organize contiguous sectors on a disk into volumes.
            See http://www.sleuthkit.org/sleuthkit/docs/api-docs/vspage.html for more details.
            </summary>
        </member>
        <member name="M:SleuthKit.VolumeSystem.#ctor(SleuthKit.DiskImage)">
            <summary>
            ctor
            </summary>
            <param name="image"></param>
        </member>
        <member name="M:SleuthKit.VolumeSystem.Dispose">
            <summary>
            Releases resources
            </summary>
        </member>
        <member name="P:SleuthKit.VolumeSystem.DiskImage">
            <summary>
            The parent disk image
            </summary>
        </member>
        <member name="P:SleuthKit.VolumeSystem.VolumeSystemInfo">
            <summary>
            Managed wrapper for TSK_VS_INFO.
            </summary>
        </member>
        <member name="P:SleuthKit.VolumeSystem.Type">
            <summary>
            The type of volume system used
            </summary>
        </member>
        <member name="P:SleuthKit.VolumeSystem.PartitionCount">
            <summary>
            The number of partitions on this volume system
            </summary>
        </member>
        <member name="P:SleuthKit.VolumeSystem.AllocatedPartitionCount">
            <summary>
            The number of partitions on this volume system that are allocated 
            </summary>
        </member>
        <member name="P:SleuthKit.VolumeSystem.BlockSize">
            <summary>
            Block size used by this volume system
            </summary>
        </member>
        <member name="P:SleuthKit.VolumeSystem.Volumes">
            <summary>
            Gets volumes
            </summary>
        </member>
    </members>
</doc>
